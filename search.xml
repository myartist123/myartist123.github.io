<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ResNetç½‘ç»œ</title>
      <link href="/2024/05/20/ResNet%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/05/20/ResNet%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="ResNetç½‘ç»œ"><a href="#ResNetç½‘ç»œ" class="headerlink" title="ResNetç½‘ç»œ"></a>ResNetç½‘ç»œ</h1><p><strong>Residual Networkï¼Œæ®‹å·®ç½‘ç»œ</strong></p><p>â€‹ResNet çš„æ ¸å¿ƒæ€æƒ³æ˜¯å¼•å…¥äº†<strong>æ®‹å·®è¿æ¥</strong>ï¼Œè¿™å…è®¸ç½‘ç»œè·³è¿‡æŸäº›å±‚çš„ç›´æ¥è¿æ¥ï¼Œå°†è¾“å…¥ç›´æ¥æ·»åŠ åˆ°ç½‘ç»œçš„åç»­å±‚è¾“å‡ºã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯è®©ç½‘ç»œå¯ä»¥<strong>å­¦ä¹ åˆ°æ®‹å·®å‡½æ•°</strong>ï¼ˆresidual functionï¼‰ï¼Œå³è¾“å…¥ä¸è¾“å‡ºä¹‹é—´çš„å·®å¼‚ï¼Œè€Œä¸æ˜¯ç›´æ¥å­¦ä¹ æ˜ å°„å…³ç³»ã€‚æ®‹å·®è¿æ¥æœ‰åŠ©äº<strong>å‡è½»æ¢¯åº¦æ¶ˆå¤±</strong>çš„é—®é¢˜ï¼Œå¹¶å…è®¸æœ‰æ•ˆåœ°è®­ç»ƒéå¸¸æ·±çš„ç½‘ç»œã€‚</p><p>â€‹ResNet ä¸­çš„åŸºæœ¬æ¨¡å—æ˜¯æ®‹å·®å—ï¼Œå®ƒç”±<strong>ä¸¤ä¸ªå·ç§¯å±‚å’Œä¸€ä¸ªè·³è·ƒè¿æ¥</strong>ç»„æˆã€‚æ®‹å·®å—é€šè¿‡æ®‹å·®è¿æ¥å°†è¾“å…¥æ·»åŠ åˆ°è¾“å‡ºä¸­ï¼Œå…è®¸æ¢¯åº¦ç›´æ¥é€šè¿‡è·³è·ƒè¿æ¥è¿›è¡Œ<strong>åå‘ä¼ æ’­</strong>ï¼Œä»è€Œæœ‰æ•ˆåœ°è§£å†³äº†æ¢¯åº¦æ¶ˆå¤±çš„é—®é¢˜ã€‚å¸¸è§çš„æ®‹å·®å—åŒ…æ‹¬åŸºæœ¬çš„æ®‹å·®å—å’Œç“¶é¢ˆæ®‹å·®å—ã€‚</p><p><img src="/../img/image-20240513114103271.png"></p><blockquote><h2 id="f-x-x-g-x"><a href="#f-x-x-g-x" class="headerlink" title="f(x) &#x3D; x + g(x)"></a><strong>f(x) &#x3D; x + g(x)</strong></h2></blockquote><p>â€‹xè¡¨ç¤ºè¾“å…¥ï¼Œ<strong>ğ‘”(ğ‘¥)<strong>è¡¨ç¤ºæ®‹å·®å—çš„</strong>å­¦ä¹ éƒ¨åˆ†</strong>ã€‚è¿™ä¸ªå…¬å¼çš„å«ä¹‰æ˜¯å°†è¾“å…¥ ğ‘¥ ä¸å­¦ä¹ åˆ°çš„æ®‹å·® ğ‘”(ğ‘¥) ç›¸åŠ ï¼Œå¾—åˆ°æ®‹å·®å—çš„è¾“å‡ºã€‚è®©ç½‘ç»œå­¦ä¹ å¦‚ä½•<strong>è°ƒæ•´è¾“å…¥ ğ‘¥</strong>ï¼Œä½¿å¾— ğ‘“(ğ‘¥)æ¥è¿‘äºæœŸæœ›çš„è¾“å‡ºã€‚</p><p>â€‹ğ‘”(ğ‘¥) æ˜¯æ®‹å·®çš„å­¦ä¹ éƒ¨åˆ†ï¼Œé€šè¿‡å·ç§¯å±‚ã€æ‰¹é‡å½’ä¸€åŒ–ç­‰æ“ä½œï¼Œå­¦ä¹ åˆ°è¾“å…¥ ğ‘¥ ä¸æœŸæœ›è¾“å‡ºä¹‹é—´çš„<strong>å·®å¼‚</strong>ã€‚è€Œ ğ‘¥åˆ™è¡¨ç¤ºè¾“å…¥çš„åŸå§‹ç‰¹å¾ã€‚å°† ğ‘¥ä¸ ğ‘”(ğ‘¥)ç›¸åŠ å¯ä»¥è®¤ä¸ºæ˜¯å¯¹ ğ‘¥ è¿›è¡Œä¸€ä¸ªâ€ä¿®æ­£â€ã€‚</p><p>â€‹è¿™æ ·ç›´æ¥åŠ ä¿è¯äº†æœ€ä¼˜è§£â€œ<strong>è‡³å°‘ä¸ä¼šå˜å·®</strong>â€ï¼Œg(x)&#x3D;0æ˜¯å’Œä»¥å‰ä¸€æ ·çš„ã€‚å‡è®¾æ²¡æœ‰å­¦åˆ°ä»»ä½•ä¸œè¥¿ï¼Œåˆ™g(x)ä¸º0</p><p><img src="/../img/image-20240513115207311.png"></p><p>â€‹åœ¨éƒ¨åˆ†æ®‹å·®å—ä¸­ï¼Œä¸ºäº†<strong>å‡å°‘ç‰¹å¾å›¾çš„ç»´åº¦</strong>ï¼Œä¼šé‡‡ç”¨å°†ç‰¹å¾å›¾é«˜åº¦å’Œå®½åº¦å‡åŠçš„æ–¹å¼ï¼Œé€šå¸¸é€šè¿‡æ­¥é•¿ä¸º 2 çš„å·ç§¯æ“ä½œ(<strong>strides&#x3D;2</strong>)æ¥å®ç°ã€‚è¿™ä¼šå¯¼è‡´ g(x) çš„é«˜åº¦å’Œå®½åº¦å‡åŠã€‚</p><p>â€‹å› æ­¤ï¼Œä¸ºæ–¹ä¾¿**x + g(x)**ï¼Œåœ¨è·³è·ƒè¿æ¥ä¸­åŠ å…¥ä¸€ä¸ªå·ç§¯å±‚ï¼ˆ1x1 convï¼‰ï¼Œè®¾ç½®strides&#x3D;2ï¼Œä¹ŸæŠŠxé«˜å®½å‡åŠäº†ã€‚</p><p><img src="/../img/image-20240513115635901.png"></p><p><img src="/../img/image-20240513115810832.png"></p><h2 id="åŸºäº-ResNet-çš„è°ƒåˆ¶æ–¹å¼è¯†åˆ«"><a href="#åŸºäº-ResNet-çš„è°ƒåˆ¶æ–¹å¼è¯†åˆ«" class="headerlink" title="åŸºäº ResNet çš„è°ƒåˆ¶æ–¹å¼è¯†åˆ«"></a>åŸºäº ResNet çš„è°ƒåˆ¶æ–¹å¼è¯†åˆ«</h2><ol><li><strong>æ•°æ®é›†å†…å®¹</strong>ï¼š<ul><li>æ•°æ®é›†åŒ…å«æ•°å­—è°ƒåˆ¶ä¿¡å·å’Œæ¨¡æ‹Ÿè°ƒåˆ¶ä¿¡å·ã€‚</li><li>ä¿¡å·ä»¥ IQï¼ˆIn-phase and Quadratureï¼‰æ•°æ®æ ¼å¼å­˜å‚¨ï¼Œæ¯ä¸ªæ ·æœ¬æœ‰ 2 Ã— 128 çš„å½¢çŠ¶ã€‚</li><li>æ€»å…±æœ‰ 220,000 ä¸ªæ ·æœ¬ï¼ˆ22ä¸‡ï¼‰ã€‚</li></ul></li><li><strong>æ•°æ®ç”Ÿæˆæ–¹å¼</strong>ï¼š<ul><li>ä½¿ç”¨ Gnuradio ç»“åˆ Python ç”Ÿæˆæ•°æ®ã€‚</li></ul></li><li><strong>è°ƒåˆ¶æ–¹å¼</strong>ï¼š<ul><li>åŒ…æ‹¬ 8 ç§æ•°å­—è°ƒåˆ¶æ–¹å¼ï¼š8PSKã€BPSKã€CPFSKã€GFSKã€PAM4ã€16QAMã€64QAMã€QPSKã€‚</li><li>è¿˜åŒ…æ‹¬ 3 ç§æ¨¡æ‹Ÿè°ƒåˆ¶æ–¹å¼ï¼šAM-DSBã€AM-SSBã€WBFMã€‚</li></ul></li><li><strong>ä¿¡å™ªæ¯”èŒƒå›´</strong>ï¼š<ul><li>ä¿¡å™ªæ¯”èŒƒå›´ä¸º -20dB åˆ° 18dBï¼Œä»¥ 2dB ä¸ºé—´éš”ã€‚</li></ul></li><li><strong>é‡‡æ ·ç‡å’Œé¢‘ç‡åç§»</strong>ï¼š<ul><li>é‡‡æ ·ç‡ä¸º 200kHzã€‚</li><li>æœ€å¤§é‡‡æ ·ç‡åç§»ä¸º 50Hzã€‚</li><li>æœ€å¤§è½½æ³¢é¢‘ç‡åç§»ä¸º 500Hzã€‚</li></ul></li><li><strong>é¢‘ç‡é€‰æ‹©æ€§è¡°è½</strong>ï¼š<ul><li>ä½¿ç”¨äº† 8 ä¸ªæ­£å¼¦æ³¢æ¥æ¨¡æ‹Ÿé¢‘ç‡é€‰æ‹©æ€§è¡°è½ã€‚</li></ul></li><li><strong>å™ªå£°å’Œä¿¡é“ç¯å¢ƒ</strong>ï¼š<ul><li>ä¿¡é“ç¯å¢ƒåŒ…æ‹¬åŠ æ€§é«˜æ–¯ç™½å™ªå£°ã€é€‰æ‹©æ€§è¡°è½ï¼ˆè±æ–¯å’Œç‘åˆ©ï¼‰ã€ä¸­å¿ƒé¢‘ç‡åç§»å’Œé‡‡æ ·ç‡åç§»ã€‚</li></ul></li><li><strong>å»¶è¿Ÿè®¾ç½®</strong>ï¼š<ul><li>æœ‰ 3 ä¸ªä¸åŒçš„å»¶è¿Ÿè®¾ç½®ï¼Œåˆ†åˆ«ä¸º [0.0, 0.9, 1.7]ã€‚</li><li>å¯¹åº”æ¯ä¸ªå»¶è¿Ÿæ—¶é—´çš„å¹…åº¦åˆ†åˆ«ä¸º [1, 0.8, 0.3]ã€‚</li></ul></li><li><strong>æ¯ä¸ªæ ·æœ¬çš„å½¢çŠ¶</strong>ï¼š<ul><li>æ¯ç§è°ƒåˆ¶æ–¹å¼ï¼Œæ¯ç§ä¿¡å™ªæ¯”çš„æ•°æ®å½¢çŠ¶ä¸º (1000, 2, 128)ã€‚</li><li>æ¯ä¸ªæ ·æœ¬ç»„æ•°æ®å½¢çŠ¶ä¸ºï¼ˆ1000ä¸ªæ ·æœ¬ï¼Œæ¯ä¸ªæ ·æœ¬æœ‰2ä¸ªç»´åº¦ï¼Œæ¯ä¸ªç»´åº¦æœ‰128ä¸ªæ•°æ®ç‚¹ï¼‰ã€‚</li></ul></li><li><strong>æ•°æ®é›†çš„ç‰¹ç‚¹</strong>ï¼š</li></ol><ul><li><p>æ¯ä¸ªæ ·æœ¬åŒ…å«äº†ä¸åŒè°ƒåˆ¶æ–¹å¼åœ¨ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„ä¿¡å·æ•°æ®ï¼Œè¿™æ ·çš„æ•°æ®é›†å¯ä»¥ç”¨äºè®­ç»ƒå’Œæµ‹è¯•è°ƒåˆ¶è¯†åˆ«ç®—æ³•ã€‚</p></li><li><p>æ•°æ®é›†æä¾›äº†ä¸°å¯Œçš„ä¿¡é“ç¯å¢ƒæ¨¡æ‹Ÿï¼Œæœ‰åŠ©äºç ”ç©¶æ•°å­—ä¿¡å·åœ¨ä¸åŒå¹²æ‰°æ¡ä»¶ä¸‹çš„æ€§èƒ½è¡¨ç°ã€‚</p><h2 id="è„šæœ¬ä»£ç å®ç°ï¼š"><a href="#è„šæœ¬ä»£ç å®ç°ï¼š" class="headerlink" title="è„šæœ¬ä»£ç å®ç°ï¼š"></a>è„šæœ¬ä»£ç å®ç°ï¼š</h2></li></ul><ol><li><strong>æ•°æ®é¢„å¤„ç†è„šæœ¬</strong> (<code>data_preprocessing.py</code>)<ul><li>ç”¨äºåŠ è½½ã€å¤„ç†å’Œåˆ†å‰²æ•°æ®ï¼Œå¹¶ä¿å­˜æ•°æ®é›†åˆ°æ–‡ä»¶ä¸­ã€‚</li><li><strong>åŠ è½½æ•°æ®é›†ï¼šdef load_data(dataset_path):</strong><br>ä»ä¸€ä¸ªåŒ…å«è°ƒåˆ¶ç±»å‹å’Œä¿¡å™ªæ¯”çš„å­—å…¸æ•°æ®é›†ä¸­åŠ è½½æ•°æ®ï¼Œå¹¶å°†å…¶é‡å¡‘ä¸ºç‰¹å®šæ ¼å¼ã€‚è¿”å›çš„æ•°æ®åŒ…å«é‡å¡‘åçš„æ•°ç»„ <code>X</code>ã€å¯¹åº”çš„æ ‡ç­¾ <code>lbl</code> ä»¥åŠä¿¡å™ªæ¯”å’Œè°ƒåˆ¶ç±»å‹çš„åˆ—è¡¨ã€‚è¿™æ ·åšå¯ä»¥æ–¹ä¾¿åç»­çš„æœºå™¨å­¦ä¹ æ¨¡å‹è¿›è¡Œè®­ç»ƒå’Œæµ‹è¯•ã€‚</li><li><strong>æ•°æ®é›†åˆ†å‰²ï¼šdef split_data</strong>(X, lbl, test_size&#x3D;0.2, val_size&#x3D;0.1, random_state&#x3D;42):<br>é€šè¿‡ä¸¤æ¬¡è°ƒç”¨ <code>train_test_split</code> å‡½æ•°ï¼Œå°†æ•°æ®é›†æŒ‰ç…§æŒ‡å®šæ¯”ä¾‹åˆ†å‰²æˆè®­ç»ƒé›†ã€éªŒè¯é›†å’Œæµ‹è¯•é›†ã€‚è¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†åœ¨æ¨¡å‹è®­ç»ƒè¿‡ç¨‹ä¸­ï¼Œå¯ä»¥æœ‰ä¸€ä¸ªç‹¬ç«‹çš„éªŒè¯é›†æ¥è°ƒæ•´è¶…å‚æ•°ï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªç‹¬ç«‹çš„æµ‹è¯•é›†æ¥è¯„ä¼°æ¨¡å‹çš„æœ€ç»ˆæ€§èƒ½ã€‚é€šè¿‡è®¾ç½® <code>random_state</code> å‚æ•°ï¼Œä¿è¯äº†æ•°æ®åˆ†å‰²çš„ç»“æœæ˜¯å¯å¤ç°çš„ã€‚</li><li><strong>ä¿å­˜æµ‹è¯•é›†æ•°æ®ï¼šdef save_test_data</strong>(X_test, lbl_test, snrs, mods, test_data_path):<br>å°†æµ‹è¯•é›†çš„æ•°æ®å’Œç›¸å…³ä¿¡æ¯ï¼ˆæ ‡ç­¾ã€ä¿¡å™ªæ¯”ã€è°ƒåˆ¶ç±»å‹ï¼‰ä¿å­˜åˆ°ä¸€ä¸ªæŒ‡å®šçš„æ–‡ä»¶ä¸­ã€‚ç¡®ä¿æµ‹è¯•æ•°æ®åœ¨éœ€è¦æ—¶å¯ä»¥æ–¹ä¾¿åœ°åŠ è½½å’Œä½¿ç”¨ã€‚ä½¿ç”¨ <code>pickle</code> æ¨¡å—è¿›è¡Œåºåˆ—åŒ–ï¼Œä½¿å¾—æ•°æ®å¯ä»¥åœ¨ä¿å­˜å’ŒåŠ è½½è¿‡ç¨‹ä¸­ä¿æŒå…¶åŸå§‹ç»“æ„å’Œç±»å‹ã€‚</li><li><strong>ä¸»å‡½æ•°</strong>ï¼š<br>æ•´åˆäº†æ•°æ®å¤„ç†çš„å„ä¸ªæ­¥éª¤ï¼Œé¦–å…ˆåŠ è½½æ•°æ®é›†ï¼Œç„¶ååˆ†å‰²æ•°æ®é›†ï¼Œæœ€åä¿å­˜æµ‹è¯•é›†æ•°æ®ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥ç¡®ä¿æ•°æ®å¤„ç†çš„å„ä¸ªæ­¥éª¤æŒ‰ç…§é¢„æœŸçš„é¡ºåºæ‰§è¡Œã€‚</li></ul></li><li><strong>æ¨¡å‹å®šä¹‰è„šæœ¬</strong> (<code>model.py</code>)<ul><li>å®šä¹‰æ¨¡å‹ç»“æ„å’Œå…¶ä»–ä¸æ¨¡å‹ç›¸å…³çš„å‡½æ•°ã€‚</li><li>å®šä¹‰äº†ä¸€ä¸ªåŸºäº ResNet34 æ¶æ„çš„ç¥ç»ç½‘ç»œæ¨¡å‹ã€‚åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼ŒåŠ è½½äº†é¢„è®­ç»ƒçš„ ResNet34 æ¨¡å‹ï¼Œå¹¶ä¿®æ”¹äº†è¾“å…¥é€šé“æ•°å’Œè¾“å‡ºç±»åˆ«æ•°ã€‚å‰å‘ä¼ æ’­æ–¹æ³•ç®€å•åœ°å°†è¾“å…¥ä¼ é€’ç»™å†…éƒ¨çš„ ResNet34 æ¨¡å‹ï¼Œå¹¶è¿”å›è¾“å‡ºç»“æœã€‚</li></ul></li><li><strong>è®­ç»ƒè„šæœ¬</strong> (<code>train.py</code>)<ul><li>åŠ è½½æ•°æ®ã€åˆå§‹åŒ–æ¨¡å‹ã€è®­ç»ƒæ¨¡å‹ã€ä¿å­˜æ¨¡å‹æƒé‡ä»¥åŠä¿å­˜æµ‹è¯•æ•°æ®é›†ã€‚</li><li><strong>å®šä¹‰æ•°æ®é›†ç±»ï¼šModulationDataset(data.Dataset):</strong><br>è¿™ä¸ªç±»å®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„æ•°æ®é›†ç±» <code>ModulationDataset</code>ï¼Œç”¨äºåŠ è½½è°ƒåˆ¶æ•°æ®é›†ã€‚é€šè¿‡å®ç° <code>__len__</code> å’Œ <code>__getitem__</code> æ–¹æ³•ï¼Œä½¿å¾—è¯¥æ•°æ®é›†å¯ä»¥è¢« PyTorch çš„æ•°æ®åŠ è½½å™¨ä½¿ç”¨ã€‚åœ¨ <code>__getitem__</code> æ–¹æ³•ä¸­ï¼Œå°†ç‰¹å¾æ•°æ®ã€è°ƒåˆ¶ç±»å‹å’Œä¿¡å™ªæ¯”ç»„åˆæˆä¸€ä¸ªæ ·æœ¬ï¼Œå¹¶æ ¹æ®éœ€è¦è¿›è¡Œæ•°æ®è½¬æ¢ã€‚è¿™ä¸ªç±»çš„è®¾è®¡ç¬¦åˆ PyTorch æ•°æ®åŠ è½½å™¨çš„è¦æ±‚ï¼Œä½¿å¾—å¯ä»¥æ–¹ä¾¿åœ°å¯¹æ•°æ®è¿›è¡Œæ‰¹é‡å¤„ç†å’Œè®­ç»ƒã€‚</li><li><strong>æ•°æ®åŠ è½½å™¨ def get_dataloaders</strong>(X_train, lbl_train, X_val, lbl_val, X_test, lbl_test, mods, snrs, batch_size&#x3D;128):<br>è¿™ä¸ªå‡½æ•°æ ¹æ®è¾“å…¥çš„è®­ç»ƒé›†ã€éªŒè¯é›†å’Œæµ‹è¯•é›†çš„ç‰¹å¾æ•°æ®å’Œæ ‡ç­¾æ•°æ®ï¼Œä»¥åŠè°ƒåˆ¶ç±»å‹å’Œä¿¡å™ªæ¯”åˆ—è¡¨ï¼Œåˆ›å»ºäº†ç›¸åº”çš„æ•°æ®é›†å¯¹è±¡å’Œæ•°æ®åŠ è½½å™¨ã€‚æ¯ä¸ªæ•°æ®åŠ è½½å™¨éƒ½å¯ä»¥ç”¨äºæ‰¹é‡åŠ è½½æ•°æ®ï¼Œå¹¶æ ¹æ®éœ€è¦å¯¹æ•°æ®è¿›è¡Œéšæœºæ‰“ä¹±ã€‚è¿™æ ·è®¾è®¡ä½¿å¾—æ•°æ®åœ¨è®­ç»ƒã€éªŒè¯å’Œæµ‹è¯•è¿‡ç¨‹ä¸­å¯ä»¥æ–¹ä¾¿åœ°è¢«åŠ è½½å’Œä½¿ç”¨ã€‚</li><li><strong>è®­ç»ƒæ¨¡å‹def train_model</strong>(model, train_loader, val_loader, criterion, optimizer, num_epochs&#x3D;20, device&#x3D;â€™cudaâ€™, model_save_path&#x3D;â€™resnet34_model.pthâ€™):<br>è¿™ä¸ªå‡½æ•°ç”¨äºè®­ç»ƒç¥ç»ç½‘ç»œæ¨¡å‹ï¼Œå¹¶åœ¨è®­ç»ƒè¿‡ç¨‹ä¸­è¿›è¡ŒéªŒè¯ï¼Œé€‰æ‹©æœ€ä½³æ¨¡å‹ã€‚é€šè¿‡å¾ªç¯éå†æ¯ä¸ªè®­ç»ƒè½®æ¬¡ï¼Œå¹¶åœ¨æ¯ä¸ªè½®æ¬¡å†…è¿­ä»£è®­ç»ƒå’ŒéªŒè¯é˜¶æ®µï¼Œå¯¹æ¨¡å‹è¿›è¡Œè®­ç»ƒå’Œè¯„ä¼°ã€‚åœ¨æ¯ä¸ªé˜¶æ®µå†…ï¼Œéƒ½è®¡ç®—å¹¶æ‰“å°æŸå¤±å’Œå‡†ç¡®ç‡ï¼Œå¹¶ä¿å­˜è®­ç»ƒè¿‡ç¨‹ä¸­çš„æœ€ä½³æ¨¡å‹ã€‚æœ€åè¿”å›è®­ç»ƒå®Œæˆçš„æœ€ä½³æ¨¡å‹ã€‚</li><li><strong>ä¸»å‡½æ•°</strong>ï¼š<br>æ•´ä¸ªè®­ç»ƒæµç¨‹çš„ä¸»æ§åˆ¶ä¸­å¿ƒï¼Œè´Ÿè´£åŠ è½½æ•°æ®ã€åˆ›å»ºæ¨¡å‹ã€è®¾ç½®æŸå¤±å‡½æ•°å’Œä¼˜åŒ–å™¨ï¼Œå¹¶è°ƒç”¨è®­ç»ƒå‡½æ•°è¿›è¡Œæ¨¡å‹è®­ç»ƒã€‚é€šè¿‡è°ƒç”¨å…¶ä»–å‡½æ•°ï¼Œå®ç°äº†æ•´ä¸ªè®­ç»ƒæµç¨‹çš„è‡ªåŠ¨åŒ–å’Œæ¨¡å—åŒ–</li></ul></li><li><strong>è¯„ä¼°å’Œå¯è§†åŒ–è„šæœ¬</strong> (<code>evaluate_and_plot.py</code>)<ul><li>åŠ è½½æ¨¡å‹å’Œæµ‹è¯•æ•°æ®ï¼Œè¿›è¡Œæ¨¡å‹è¯„ä¼°ï¼Œå¹¶ç”Ÿæˆå„ç§å¯è§†åŒ–å›¾è¡¨ã€‚</li><li><strong>å®šä¹‰æ•°æ®é›†ç±»ï¼šModulationDataset(data.Dataset):</strong><br>è¿™ä¸ªç±»å®šä¹‰äº†ä¸€ä¸ªè‡ªå®šä¹‰çš„æ•°æ®é›†ç±» <code>ModulationDataset</code>ï¼Œç”¨äºåŠ è½½è°ƒåˆ¶æ•°æ®é›†ã€‚é€šè¿‡å®ç° <code>__len__</code> å’Œ <code>__getitem__</code> æ–¹æ³•ï¼Œä½¿å¾—è¯¥æ•°æ®é›†å¯ä»¥è¢« PyTorch çš„æ•°æ®åŠ è½½å™¨ä½¿ç”¨ã€‚åœ¨ <code>__getitem__</code> æ–¹æ³•ä¸­ï¼Œå°†ç‰¹å¾æ•°æ®ã€è°ƒåˆ¶ç±»å‹å’Œä¿¡å™ªæ¯”ç»„åˆæˆä¸€ä¸ªæ ·æœ¬ï¼Œå¹¶æ ¹æ®éœ€è¦è¿›è¡Œæ•°æ®è½¬æ¢ã€‚è¿™ä¸ªç±»çš„è®¾è®¡ç¬¦åˆ PyTorch æ•°æ®åŠ è½½å™¨çš„è¦æ±‚ï¼Œä½¿å¾—å¯ä»¥æ–¹ä¾¿åœ°å¯¹æ•°æ®è¿›è¡Œæ‰¹é‡å¤„ç†å’Œè®­ç»ƒã€‚</li><li><strong>åŠ è½½é¢„å…ˆä¿å­˜çš„æµ‹è¯•é›†æ•°æ®ï¼šdef load_test_data</strong>(test_data_path):<br>åŠ è½½é¢„å…ˆä¿å­˜çš„æµ‹è¯•é›†æ•°æ®ï¼Œå¹¶è¿”å›åŠ è½½çš„æµ‹è¯•é›†ç‰¹å¾æ•°æ®ã€æ ‡ç­¾æ•°æ®ã€ä¿¡å™ªæ¯”åˆ—è¡¨å’Œè°ƒåˆ¶ç±»å‹åˆ—è¡¨ã€‚é€šè¿‡ä½¿ç”¨ <code>pickle</code> æ¨¡å—è¿›è¡Œæ•°æ®çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ï¼Œå¯ä»¥æ–¹ä¾¿åœ°åœ¨ä¸åŒçš„è„šæœ¬ä¸­ä¿å­˜å’ŒåŠ è½½æ•°æ®ï¼Œä½¿å¾—æµ‹è¯•æ•°æ®å¯ä»¥åœ¨éœ€è¦æ—¶è¢«è½»æ¾åœ°åŠ è½½å’Œä½¿ç”¨ã€‚</li><li><strong>è¯„ä¼°æ¨¡å‹ï¼šdef evaluate_model</strong>(model, dataloader, device&#x3D;â€™cudaâ€™):<br>ç”¨äºè¯„ä¼°æ¨¡å‹åœ¨ç»™å®šæ•°æ®é›†ä¸Šçš„æ€§èƒ½ï¼ŒåŒ…æ‹¬è®¡ç®—å‡†ç¡®ç‡ä»¥åŠä¿å­˜æ‰€æœ‰é¢„æµ‹ã€æ‰€æœ‰æ ‡ç­¾å’Œæ‰€æœ‰ä¿¡å™ªæ¯”ã€‚é€šè¿‡è¿­ä»£æ•°æ®åŠ è½½å™¨ï¼Œå°†æ•°æ®ä¼ é€’ç»™æ¨¡å‹è¿›è¡Œæ¨ç†ï¼Œå¹¶ç»Ÿè®¡æ¨¡å‹çš„æ­£ç¡®é¢„æµ‹æ•°ï¼Œæœ€åè®¡ç®—å‡†ç¡®ç‡å¹¶è¿”å›ç»“æœã€‚</li><li><strong>ç»˜åˆ¶ç»“æœå›¾å‡½æ•°ï¼š</strong><br>ç»˜åˆ¶ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„å¹³å‡å‡†ç¡®ç‡æŠ˜çº¿å›¾<br>ç»˜åˆ¶ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„è°ƒåˆ¶æ–¹å¼å‡†ç¡®ç‡æŠ˜çº¿å›¾<br>ç»˜åˆ¶æ··æ·†çŸ©é˜µ</li><li><strong>ä¸»å‡½æ•°</strong>ï¼š<br>å®ç°äº†æ•´ä¸ªæ¨¡å‹è¯„ä¼°çš„æµç¨‹ï¼ŒåŒ…æ‹¬åŠ è½½ä¿å­˜çš„æ¨¡å‹ã€è¯„ä¼°æ¨¡å‹æ€§èƒ½ã€è®¡ç®—å¹³å‡å‡†ç¡®ç‡å¹¶ç»˜åˆ¶ç›¸åº”å›¾åƒã€‚é€šè¿‡è¿™äº›æ­¥éª¤ï¼Œå¯ä»¥å…¨é¢åœ°äº†è§£æ¨¡å‹åœ¨æµ‹è¯•é›†ä¸Šçš„æ€§èƒ½è¡¨ç°ï¼Œå¹¶è¿›è¡Œå¯è§†åŒ–åˆ†æï¼Œä»è€Œè¿›ä¸€æ­¥ä¼˜åŒ–å’Œæ”¹è¿›æ¨¡å‹ã€‚</li></ul></li></ol><p><img src="/../img/image-20240515122934153.png"></p><p><img src="/../img/image-20240515123054363.png"></p><p><img src="/../img/image-20240515123157067.png"></p><p><img src="/../img/image-20240515123241610.png"></p><p><img src="/../img/image-20240515123307616.png"></p>]]></content>
      
      
      <categories>
          
          <category> æ·±åº¦å­¦ä¹  </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resnet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ResNet ä¸€äº›å†™ä½œæ ¼å¼æŠ€å·§</title>
      <link href="/2024/05/20/%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/05/20/%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="ä¸€äº›æŠ€å·§"><a href="#ä¸€äº›æŠ€å·§" class="headerlink" title="ä¸€äº›æŠ€å·§"></a>ä¸€äº›æŠ€å·§</h1><p><strong>è¿˜æ˜¯è®¡ç®—æœº</strong></p><p><strong>åŠ ç²—Ctrl+B</strong><br><em>æ–œä½“Ctrl+I</em></p><blockquote><p>è¿™æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œ&gt;+å†…å®¹ï¼Œå¤šå±‚å¤š+å‡ ä¸ª&gt;</p></blockquote><p><a href="https://blog.csdn.net/qq_40818172?type=lately">è¿™æ˜¯å°ç™½çš„ä¸»é¡µ</a></p><p><a href="https://blog.csdn.net/qq_40818172?type=lately">https://blog.csdn.net/qq_40818172?type=lately</a></p><p><img src="/"></p><p>æ— åºåˆ—è¡¨ï¼Œä½¿ç”¨<code>*</code>ã€<code>+</code>ã€<code>-</code>ï¼Œå†åŠ ä¸€ä¸ªç©ºæ ¼ä½œä¸ºåˆ—è¡¨çš„æ ‡è®°</p><ul><li>hhdbcbjhbhj</li></ul><ol><li>hghjggjh</li><li>jbhjbhjbjh</li></ol><p>åˆ†å‰²çº¿çˆ±ä½ ï¼šâ€”&#x2F;***</p><hr><hr><p>åˆ é™¤çº¿ï¼š~~</p><p><del>é•¿æ±Ÿç´¢é“ä½•å°ä¸æ˜¯å‡ºç‰ˆç¤¾</del></p><p>ä¸‹åˆ’çº¿ï¼šå°¾æ·»åŠ <code>&lt;u&gt;æ–‡æœ¬&lt;/u&gt;</code></p><p>ä»£ç å—ï¼š<code>hbhb</code></p><p>ä»£ç æ®µï¼šä¸‰ä¸ª&#96;&#96;&#96;</p><p>è¡¨æ ¼ä½¿ç”¨<code>|</code>æ¥åˆ†å‰²ä¸åŒçš„å•å…ƒæ ¼ï¼Œä½¿ç”¨<code>-</code>æ¥åˆ†éš”è¡¨å¤´å’Œå…¶ä»–è¡Œ</p><ul><li><code>:-</code>ï¼šå°†è¡¨å¤´åŠå•å…ƒæ ¼å†…å®¹å·¦å¯¹é½</li><li><code>-:</code>ï¼šå°†è¡¨å¤´åŠå•å…ƒæ ¼å†…å®¹å³å¯¹é½</li><li><code>:-:</code>ï¼šå°†è¡¨å¤´åŠå•å…ƒæ ¼å†…å®¹å±…ä¸­</li></ul>]]></content>
      
      
      <categories>
          
          <category> æœªåˆ†ç±» </category>
          
      </categories>
      
      
        <tags>
            
            <tag> æ ¼å¼ </tag>
            
            <tag> æŠ€å·§ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ResNet ä¿¡å·è°ƒåˆ¶è¯†åˆ«</title>
      <link href="/2024/05/19/ResNet%20%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/"/>
      <url>/2024/05/19/ResNet%20%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="ResNet-ä¿¡å·è°ƒåˆ¶è¯†åˆ«"><a href="#ResNet-ä¿¡å·è°ƒåˆ¶è¯†åˆ«" class="headerlink" title="ResNet ä¿¡å·è°ƒåˆ¶è¯†åˆ«"></a>ResNet ä¿¡å·è°ƒåˆ¶è¯†åˆ«</h1><p>&lt;img src&#x3D;â€&#x2F;img&#x2F;image-20240513193204914.pngâ€ style&#x3D;â€zoom:50%;â€ &#x2F;</p><p><img src="/../img/image-20240513193204914.png"></p><p>æ•°æ®é›†ï¼šRML2016.10a</p><p><img src="/../img/image-20240513203107410.png"></p><p><img src="/../img/image-20240513203123926.png"></p><p><img src="/../img/image-20240513203151707.png"></p><ol><li><strong>æ•°æ®é¢„å¤„ç†å’ŒåŠ è½½</strong>ï¼š<ul><li>å°†æ•°æ®é›†åˆ†ä¸ºè®­ç»ƒé›†ã€éªŒè¯é›†å’Œæµ‹è¯•é›†ã€‚</li><li>ä½¿ç”¨DataLoaderæ¥åŠ è½½æ•°æ®ã€‚</li></ul></li><li><strong>å®šä¹‰ResNet34æ¨¡å‹</strong>ï¼š<ul><li>ä½¿ç”¨PyTorchçš„é¢„è®­ç»ƒæ¨¡å‹ï¼Œå¹¶è°ƒæ•´æœ€åä¸€å±‚ä»¥é€‚åº”11ç§è°ƒåˆ¶æ–¹å¼ã€‚</li></ul></li><li><strong>è®­ç»ƒæ¨¡å‹</strong>ï¼š<ul><li>å®šä¹‰è®­ç»ƒå¾ªç¯ï¼ŒåŒ…æ‹¬æŸå¤±å‡½æ•°å’Œä¼˜åŒ–å™¨ã€‚</li><li>å®ç°éªŒè¯å¾ªç¯ä»¥è¯„ä¼°æ¨¡å‹åœ¨éªŒè¯é›†ä¸Šçš„è¡¨ç°ã€‚</li></ul></li><li><strong>è¯„ä¼°å’Œå¯è§†åŒ–ç»“æœ</strong>ï¼š<ul><li>è®¡ç®—ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„å¹³å‡å‡†ç¡®ç‡å¹¶ç»˜åˆ¶æŠ˜çº¿å›¾ã€‚</li><li>è®¡ç®—ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„è°ƒåˆ¶æ–¹å¼å‡†ç¡®ç‡å¹¶ç»˜åˆ¶æŠ˜çº¿å›¾ã€‚</li><li>ç”Ÿæˆæ··æ·†çŸ©é˜µä»¥å±•ç¤ºä¸åŒè°ƒåˆ¶æ–¹å¼çš„åˆ†ç±»æ•ˆæœã€‚</li></ul></li></ol><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> pickle  <span class="comment"># æ·»åŠ è¿™è¡Œæ¥å¯¼å…¥pickleæ¨¡å—</span><span class="keyword">import</span> time<span class="keyword">import</span> numpy <span class="keyword">as</span> np<span class="keyword">import</span> torch<span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn<span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim<span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data<span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, ConfusionMatrixDisplay<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split<span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm<span class="keyword">import</span> copy  <span class="comment"># æ·»åŠ è¿™è¡Œæ¥å¯¼å…¥copyæ¨¡å—</span><span class="comment"># æ•°æ®é›†è·¯å¾„</span>dataset_path = <span class="string">&#x27;RML2016.10a_dict.pkl&#x27;</span>model_save_path = <span class="string">&#x27;resnet34_model.pth&#x27;</span><span class="comment"># åŠ è½½æ•°æ®é›†</span><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">dataset_path</span>):    <span class="keyword">with</span> <span class="built_in">open</span>(dataset_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:        Xd = pickle.load(f, encoding=<span class="string">&#x27;latin1&#x27;</span>)    snrs, mods = <span class="built_in">map</span>(<span class="keyword">lambda</span> j: <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[j], Xd.keys())))), [<span class="number">1</span>, <span class="number">0</span>])    X = []    lbl = []    <span class="keyword">for</span> mod <span class="keyword">in</span> mods:        <span class="keyword">for</span> snr <span class="keyword">in</span> snrs:            X.append(Xd[(mod, snr)])            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Xd[(mod, snr)].shape[<span class="number">0</span>]):                lbl.append((mod, snr))    X = np.vstack(X)    <span class="keyword">return</span> X, lbl, snrs, mods<span class="comment"># æ•°æ®é›†åˆ†å‰²</span><span class="keyword">def</span> <span class="title function_">split_data</span>(<span class="params">X, lbl, test_size=<span class="number">0.2</span>, val_size=<span class="number">0.1</span>, random_state=<span class="number">42</span></span>):    n_samples = <span class="built_in">len</span>(lbl)    n_test = <span class="built_in">int</span>(n_samples * test_size)    n_val = <span class="built_in">int</span>(n_samples * val_size)    X_train_val, X_test, lbl_train_val, lbl_test = train_test_split(X, lbl, test_size=n_test, random_state=random_state)    X_train, X_val, lbl_train, lbl_val = train_test_split(X_train_val, lbl_train_val, test_size=n_val, random_state=random_state)    <span class="keyword">return</span> (X_train, lbl_train), (X_val, lbl_val), (X_test, lbl_test)<span class="comment"># å®šä¹‰æ•°æ®é›†ç±»</span><span class="keyword">class</span> <span class="title class_">ModulationDataset</span>(data.Dataset):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, X, lbl, mods, snrs, transform=<span class="literal">None</span></span>):        self.X = X        self.lbl = lbl        self.mods = mods        self.snrs = snrs        self.transform = transform    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="built_in">len</span>(self.lbl)    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):        sample = self.X[idx]        sample = np.expand_dims(sample, axis=<span class="number">1</span>)  <span class="comment"># å¢åŠ ä¸€ä¸ªç»´åº¦</span>        label = self.mods.index(self.lbl[idx][<span class="number">0</span>])        snr = self.snrs.index(self.lbl[idx][<span class="number">1</span>])        <span class="keyword">if</span> self.transform:            sample = self.transform(sample)        <span class="keyword">return</span> sample, label, snr<span class="comment"># æ•°æ®åŠ è½½å™¨</span><span class="keyword">def</span> <span class="title function_">get_dataloaders</span>(<span class="params">X_train, lbl_train, X_val, lbl_val, X_test, lbl_test, mods, snrs, batch_size=<span class="number">128</span></span>):    train_dataset = ModulationDataset(X_train, lbl_train, mods, snrs, transform=torch.tensor)    val_dataset = ModulationDataset(X_val, lbl_val, mods, snrs, transform=torch.tensor)    test_dataset = ModulationDataset(X_test, lbl_test, mods, snrs, transform=torch.tensor)    train_loader = data.DataLoader(train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)    val_loader = data.DataLoader(val_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span>)    test_loader = data.DataLoader(test_dataset, batch_size=batch_size, shuffle=<span class="literal">False</span>)    <span class="keyword">return</span> train_loader, val_loader, test_loader<span class="comment"># å®šä¹‰ResNet34æ¨¡å‹</span><span class="keyword">class</span> <span class="title class_">ResNet34</span>(nn.Module):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">11</span></span>):        <span class="built_in">super</span>(ResNet34, self).__init__()        self.model = models.resnet34(pretrained=<span class="literal">True</span>)        self.model.conv1 = nn.Conv2d(<span class="number">2</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)        self.model.fc = nn.Linear(<span class="number">512</span>, num_classes)    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):        <span class="keyword">return</span> self.model(x)<span class="comment"># è®­ç»ƒæ¨¡å‹</span><span class="keyword">def</span> <span class="title function_">train_model</span>(<span class="params">model, train_loader, val_loader, criterion, optimizer, num_epochs=<span class="number">10</span>, device=<span class="string">&#x27;cuda&#x27;</span>, model_save_path=<span class="string">&#x27;resnet34_model.pth&#x27;</span></span>):    best_model_wts = copy.deepcopy(model.state_dict())    best_acc = <span class="number">0.0</span>    <span class="built_in">print</span>(<span class="string">f&#x27;Training on <span class="subst">&#123;device&#125;</span>&#x27;</span>)    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch <span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;num_epochs - <span class="number">1</span>&#125;</span>&#x27;</span>)        <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">10</span>)        epoch_start = time.time()        <span class="keyword">for</span> phase <span class="keyword">in</span> [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>]:            <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:                model.train()                dataloader = train_loader            <span class="keyword">else</span>:                model.<span class="built_in">eval</span>()                dataloader = val_loader            running_loss = <span class="number">0.0</span>            running_corrects = <span class="number">0</span>            <span class="keyword">for</span> inputs, labels, _ <span class="keyword">in</span> tqdm(dataloader):                inputs = inputs.to(device).<span class="built_in">float</span>()                labels = labels.to(device)                optimizer.zero_grad()                <span class="keyword">with</span> torch.set_grad_enabled(phase == <span class="string">&#x27;train&#x27;</span>):                    outputs = model(inputs)                    _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)                    loss = criterion(outputs, labels)                    <span class="keyword">if</span> phase == <span class="string">&#x27;train&#x27;</span>:                        loss.backward()                        optimizer.step()                running_loss += loss.item() * inputs.size(<span class="number">0</span>)                running_corrects += torch.<span class="built_in">sum</span>(preds == labels.data)            epoch_loss = running_loss / <span class="built_in">len</span>(dataloader.dataset)            epoch_acc = running_corrects.double() / <span class="built_in">len</span>(dataloader.dataset)            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;phase&#125;</span> Loss: <span class="subst">&#123;epoch_loss:<span class="number">.4</span>f&#125;</span> Acc: <span class="subst">&#123;epoch_acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)            <span class="keyword">if</span> phase == <span class="string">&#x27;val&#x27;</span> <span class="keyword">and</span> epoch_acc &gt; best_acc:                best_acc = epoch_acc                best_model_wts = copy.deepcopy(model.state_dict())        epoch_time = time.time() - epoch_start        <span class="built_in">print</span>(<span class="string">f&#x27;Time for epoch <span class="subst">&#123;epoch&#125;</span>: <span class="subst">&#123;epoch_time:<span class="number">.2</span>f&#125;</span> seconds&#x27;</span>)        torch.save(model.state_dict(), model_save_path)    <span class="built_in">print</span>(<span class="string">f&#x27;Best val Acc: <span class="subst">&#123;best_acc:4f&#125;</span>&#x27;</span>)    model.load_state_dict(best_model_wts)    <span class="keyword">return</span> model<span class="comment"># è¯„ä¼°æ¨¡å‹</span><span class="keyword">def</span> <span class="title function_">evaluate_model</span>(<span class="params">model, dataloader, device=<span class="string">&#x27;cuda&#x27;</span></span>):    model.<span class="built_in">eval</span>()    running_corrects = <span class="number">0</span>    all_preds = []    all_labels = []    all_snrs = []    <span class="built_in">print</span>(<span class="string">f&#x27;Evaluating on <span class="subst">&#123;device&#125;</span>&#x27;</span>)    <span class="keyword">for</span> inputs, labels, snrs <span class="keyword">in</span> tqdm(dataloader):        inputs = inputs.to(device).<span class="built_in">float</span>()        labels = labels.to(device)        <span class="keyword">with</span> torch.set_grad_enabled(<span class="literal">False</span>):            outputs = model(inputs)            _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)        running_corrects += torch.<span class="built_in">sum</span>(preds == labels.data)        all_preds.extend(preds.cpu().numpy())        all_labels.extend(labels.cpu().numpy())        all_snrs.extend(snrs.numpy())    acc = running_corrects.double() / <span class="built_in">len</span>(dataloader.dataset)    <span class="keyword">return</span> acc, all_preds, all_labels, all_snrs<span class="comment"># ç»˜åˆ¶ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„å¹³å‡å‡†ç¡®ç‡æŠ˜çº¿å›¾</span><span class="keyword">def</span> <span class="title function_">plot_avg_accuracy</span>(<span class="params">snrs, accuracies</span>):    plt.figure()    plt.plot(snrs, accuracies)    plt.xlabel(<span class="string">&#x27;SNR (dB)&#x27;</span>)    plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)    plt.title(<span class="string">&#x27;Average Accuracy vs SNR&#x27;</span>)    plt.grid(<span class="literal">True</span>)    plt.show()<span class="comment"># ç»˜åˆ¶ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„è°ƒåˆ¶æ–¹å¼å‡†ç¡®ç‡æŠ˜çº¿å›¾</span><span class="keyword">def</span> <span class="title function_">plot_mod_accuracy</span>(<span class="params">snrs, mod_accuracies, mods</span>):    <span class="keyword">for</span> i, mod <span class="keyword">in</span> <span class="built_in">enumerate</span>(mods):        plt.plot(snrs, mod_accuracies[i], label=mod)    plt.xlabel(<span class="string">&#x27;SNR (dB)&#x27;</span>)    plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)    plt.title(<span class="string">&#x27;Modulation Accuracy vs SNR&#x27;</span>)    plt.legend()    plt.grid(<span class="literal">True</span>)    plt.show()<span class="comment"># ç»˜åˆ¶æ··æ·†çŸ©é˜µ</span><span class="keyword">def</span> <span class="title function_">plot_confusion_matrix</span>(<span class="params">y_true, y_pred, mods</span>):    cm = confusion_matrix(y_true, y_pred)    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=mods)    disp.plot(cmap=plt.cm.Blues)    plt.show()<span class="comment"># ä¸»å‡½æ•°</span><span class="keyword">def</span> <span class="title function_">main</span>():    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)    X, lbl, snrs, mods = load_data(dataset_path)        (X_train, lbl_train), (X_val, lbl_val), (X_test, lbl_test) = split_data(X, lbl)    train_loader, val_loader, test_loader = get_dataloaders(X_train, lbl_train, X_val, lbl_val, X_test, lbl_test, mods, snrs)    model = ResNet34(num_classes=<span class="built_in">len</span>(mods)).to(device)    criterion = nn.CrossEntropyLoss()    optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)    <span class="keyword">if</span> os.path.exists(model_save_path):        <span class="built_in">print</span>(<span class="string">&quot;Loading saved model...&quot;</span>)        model.load_state_dict(torch.load(model_save_path))    <span class="keyword">else</span>:        model = train_model(model, train_loader, val_loader, criterion, optimizer, num_epochs=<span class="number">10</span>, device=device, model_save_path=model_save_path)    acc, all_preds, all_labels, all_snrs = evaluate_model(model, test_loader, device=device)    <span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)    snr_acc = &#123;snr: [] <span class="keyword">for</span> snr <span class="keyword">in</span> snrs&#125;    <span class="keyword">for</span> snr, label, pred <span class="keyword">in</span> <span class="built_in">zip</span>(all_snrs, all_labels, all_preds):        <span class="keyword">if</span> snr <span class="keyword">in</span> snr_acc:            snr_acc[snr].append(label == pred)        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">f&#x27;Warning: SNR <span class="subst">&#123;snr&#125;</span> not found in snr_acc dictionary.&#x27;</span>)    avg_accuracy = [np.mean(snr_acc[snr]) <span class="keyword">for</span> snr <span class="keyword">in</span> snrs]    plot_avg_accuracy(snrs, avg_accuracy)    mod_snr_acc = &#123;mod: &#123;snr: [] <span class="keyword">for</span> snr <span class="keyword">in</span> snrs&#125; <span class="keyword">for</span> mod <span class="keyword">in</span> mods&#125;    <span class="keyword">for</span> snr, label, pred <span class="keyword">in</span> <span class="built_in">zip</span>(all_snrs, all_labels, all_preds):        mod_snr_acc[mods[label]][snr].append(label == pred)    mod_accuracy = [[np.mean(mod_snr_acc[mod][snr]) <span class="keyword">for</span> snr <span class="keyword">in</span> snrs] <span class="keyword">for</span> mod <span class="keyword">in</span> mods]    plot_mod_accuracy(snrs, mod_accuracy, mods)    plot_confusion_matrix(all_labels, all_preds, mods)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    main()</code></pre><pre><code class="highlight python"><span class="keyword">import</span> os<span class="keyword">import</span> pickle<span class="keyword">import</span> numpy <span class="keyword">as</span> np<span class="keyword">import</span> torch<span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn<span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data<span class="keyword">import</span> torchvision.models <span class="keyword">as</span> models<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt<span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, ConfusionMatrixDisplay<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split<span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm<span class="comment"># æ•°æ®é›†è·¯å¾„å’Œæ¨¡å‹ä¿å­˜è·¯å¾„</span>dataset_path = <span class="string">&#x27;RML2016.10a_dict.pkl&#x27;</span>model_save_path = <span class="string">&#x27;resnet34_model.pth&#x27;</span><span class="comment"># åŠ è½½æ•°æ®é›†</span><span class="keyword">def</span> <span class="title function_">load_data</span>(<span class="params">dataset_path</span>):    <span class="keyword">with</span> <span class="built_in">open</span>(dataset_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:        Xd = pickle.load(f, encoding=<span class="string">&#x27;latin1&#x27;</span>)    snrs, mods = <span class="built_in">map</span>(<span class="keyword">lambda</span> j: <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x[j], Xd.keys())))), [<span class="number">1</span>, <span class="number">0</span>])    X = []    lbl = []    <span class="keyword">for</span> mod <span class="keyword">in</span> mods:        <span class="keyword">for</span> snr <span class="keyword">in</span> snrs:            X.append(Xd[(mod, snr)])            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Xd[(mod, snr)].shape[<span class="number">0</span>]):                lbl.append((mod, snr))    X = np.vstack(X)    <span class="keyword">return</span> X, lbl, snrs, mods<span class="comment"># æ•°æ®é›†åˆ†å‰²ï¼Œä»…è·å–æµ‹è¯•é›†</span><span class="keyword">def</span> <span class="title function_">split_data</span>(<span class="params">X, lbl, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span></span>):    _, X_test, _, lbl_test = train_test_split(X, lbl, test_size=test_size, random_state=random_state)    <span class="keyword">return</span> X_test, lbl_test<span class="comment"># å®šä¹‰æ•°æ®é›†ç±»</span><span class="keyword">class</span> <span class="title class_">ModulationDataset</span>(data.Dataset):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, X, lbl, mods, snrs, transform=<span class="literal">None</span></span>):        self.X = X        self.lbl = lbl        self.mods = mods        self.snrs = snrs        self.transform = transform    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="built_in">len</span>(self.lbl)    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):        sample = self.X[idx]        sample = np.expand_dims(sample, axis=<span class="number">1</span>)        label = self.mods.index(self.lbl[idx][<span class="number">0</span>])        snr = self.snrs.index(self.lbl[idx][<span class="number">1</span>])        <span class="keyword">if</span> self.transform:            sample = self.transform(sample)        <span class="keyword">return</span> sample, label, snr<span class="comment"># æ•°æ®åŠ è½½å™¨</span><span class="keyword">def</span> <span class="title function_">get_dataloader</span>(<span class="params">X, lbl, mods, snrs, batch_size=<span class="number">128</span>, shuffle=<span class="literal">False</span></span>):    dataset = ModulationDataset(X, lbl, mods, snrs, transform=torch.tensor)    dataloader = data.DataLoader(dataset, batch_size=batch_size, shuffle=shuffle)    <span class="keyword">return</span> dataloader<span class="comment"># å®šä¹‰ResNet34æ¨¡å‹</span><span class="keyword">class</span> <span class="title class_">ResNet34</span>(nn.Module):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">11</span></span>):        <span class="built_in">super</span>(ResNet34, self).__init__()        self.model = models.resnet34(pretrained=<span class="literal">True</span>)        self.model.conv1 = nn.Conv2d(<span class="number">2</span>, <span class="number">64</span>, kernel_size=<span class="number">7</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>, bias=<span class="literal">False</span>)        self.model.fc = nn.Linear(<span class="number">512</span>, num_classes)    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):        <span class="keyword">return</span> self.model(x)<span class="comment"># è¯„ä¼°æ¨¡å‹</span><span class="keyword">def</span> <span class="title function_">evaluate_model</span>(<span class="params">model, dataloader, device=<span class="string">&#x27;cuda&#x27;</span></span>):    model.<span class="built_in">eval</span>()    running_corrects = <span class="number">0</span>    all_preds = []    all_labels = []    all_snrs = []    <span class="built_in">print</span>(<span class="string">f&#x27;Evaluating on <span class="subst">&#123;device&#125;</span>&#x27;</span>)    <span class="keyword">for</span> inputs, labels, snrs <span class="keyword">in</span> tqdm(dataloader):        inputs = inputs.to(device).<span class="built_in">float</span>()        labels = labels.to(device)        <span class="keyword">with</span> torch.set_grad_enabled(<span class="literal">False</span>):            outputs = model(inputs)            _, preds = torch.<span class="built_in">max</span>(outputs, <span class="number">1</span>)        running_corrects += torch.<span class="built_in">sum</span>(preds == labels.data)        all_preds.extend(preds.cpu().numpy())        all_labels.extend(labels.cpu().numpy())        all_snrs.extend(snrs.numpy())    acc = running_corrects.double() / <span class="built_in">len</span>(dataloader.dataset)    <span class="keyword">return</span> acc, all_preds, all_labels, all_snrs<span class="comment"># ç»˜åˆ¶ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„å¹³å‡å‡†ç¡®ç‡æŠ˜çº¿å›¾</span><span class="keyword">def</span> <span class="title function_">plot_avg_accuracy</span>(<span class="params">snrs, accuracies</span>):    plt.figure()    plt.plot(snrs, accuracies)    plt.xlabel(<span class="string">&#x27;SNR (dB)&#x27;</span>)    plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)    plt.title(<span class="string">&#x27;Average Accuracy vs SNR&#x27;</span>)    plt.grid(<span class="literal">True</span>)    plt.savefig(<span class="string">&#x27;avg_accuracy.png&#x27;</span>)    plt.show()<span class="comment"># ç»˜åˆ¶ä¸åŒä¿¡å™ªæ¯”ä¸‹çš„è°ƒåˆ¶æ–¹å¼å‡†ç¡®ç‡æŠ˜çº¿å›¾</span><span class="keyword">def</span> <span class="title function_">plot_mod_accuracy</span>(<span class="params">snrs, mod_accuracies, mods</span>):    <span class="keyword">for</span> i, mod <span class="keyword">in</span> <span class="built_in">enumerate</span>(mods):        plt.plot(snrs, mod_accuracies[i], label=mod)    plt.xlabel(<span class="string">&#x27;SNR (dB)&#x27;</span>)    plt.ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)    plt.title(<span class="string">&#x27;Modulation Accuracy vs SNR&#x27;</span>)    plt.legend()    plt.grid(<span class="literal">True</span>)    plt.savefig(<span class="string">&#x27;mod_accuracy.png&#x27;</span>)    plt.show()<span class="comment"># ç»˜åˆ¶æ··æ·†çŸ©é˜µ</span><span class="keyword">def</span> <span class="title function_">plot_confusion_matrix</span>(<span class="params">y_true, y_pred, mods</span>):    cm = confusion_matrix(y_true, y_pred)    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=mods)    fig, ax = plt.subplots(figsize=(<span class="number">10</span>, <span class="number">10</span>))  <span class="comment"># è°ƒæ•´å›¾åƒå¤§å°</span>    disp.plot(cmap=plt.cm.Blues, ax=ax, xticks_rotation=<span class="string">&#x27;vertical&#x27;</span>)  <span class="comment"># æ ‡ç­¾ç«–ç›´æ˜¾ç¤º</span>    plt.xlabel(<span class="string">&#x27;Predicted label&#x27;</span>, fontsize=<span class="number">12</span>)    plt.ylabel(<span class="string">&#x27;True label&#x27;</span>, fontsize=<span class="number">12</span>)    plt.title(<span class="string">&#x27;Confusion Matrix&#x27;</span>, fontsize=<span class="number">14</span>)    plt.savefig(<span class="string">&#x27;confusion_matrix.png&#x27;</span>)    plt.show()<span class="comment"># ä¸»å‡½æ•°</span><span class="keyword">def</span> <span class="title function_">main</span>():    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)    X, lbl, snrs, mods = load_data(dataset_path)    X_test, lbl_test = split_data(X, lbl)    test_loader = get_dataloader(X_test, lbl_test, mods, snrs, shuffle=<span class="literal">False</span>)    model = ResNet34(num_classes=<span class="built_in">len</span>(mods)).to(device)    <span class="keyword">if</span> os.path.exists(model_save_path):        <span class="built_in">print</span>(<span class="string">&quot;Loading saved model...&quot;</span>)        model.load_state_dict(torch.load(model_save_path))    <span class="keyword">else</span>:        <span class="keyword">raise</span> FileNotFoundError(<span class="string">f&#x27;Model file not found at <span class="subst">&#123;model_save_path&#125;</span>. Please train the model first.&#x27;</span>)    acc, all_preds, all_labels, all_snrs = evaluate_model(model, test_loader, device=device)    <span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;acc:<span class="number">.4</span>f&#125;</span>&#x27;</span>)    snr_acc = &#123;snr: [] <span class="keyword">for</span> snr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snrs))&#125;    <span class="keyword">for</span> snr, label, pred <span class="keyword">in</span> <span class="built_in">zip</span>(all_snrs, all_labels, all_preds):        snr_acc[snr].append(label == pred)    avg_accuracy = [np.mean(snr_acc[snr]) <span class="keyword">if</span> snr_acc[snr] <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> snr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snrs))]    plot_avg_accuracy(snrs, avg_accuracy)    mod_snr_acc = &#123;mod: &#123;snr: [] <span class="keyword">for</span> snr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snrs))&#125; <span class="keyword">for</span> mod <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mods))&#125;    <span class="keyword">for</span> snr, label, pred <span class="keyword">in</span> <span class="built_in">zip</span>(all_snrs, all_labels, all_preds):        mod_snr_acc[label][snr].append(label == pred)    mod_accuracy = [[np.mean(mod_snr_acc[mod][snr]) <span class="keyword">if</span> mod_snr_acc[mod][snr] <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> snr <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snrs))] <span class="keyword">for</span> mod <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mods))]    plot_mod_accuracy(snrs, mod_accuracy, mods)    plot_confusion_matrix(all_labels, all_preds, mods)<span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:    main()</code></pre>]]></content>
      
      
      <categories>
          
          <category> æ·±åº¦å­¦ä¹  </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resnet </tag>
            
            <tag> è°ƒåˆ¶è¯†åˆ« </tag>
            
            <tag> RML2016.10a </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
